import { createCanvasAnd2dContext, type Bounds, type CanvasAndContext } from "./utils";
import Vec2 from "./Vec2";

/**
 * Options to be applied to the light object.
 */
export type LightOptions = Partial<
  Pick<Light, "position" | "distance" | "diffuse" | "samples" | "hidden">
>;

/**
 * A light object.
 */
export default class Light {
  /**
   * Position of the light object.
   *
   * @default new Vec2()
   */
  public position: Vec2;

  /**
   * Intensity of the light.
   *
   * @default 100
   */
  public distance: number;

  /**
   * The intensity of the light penetration in objects.
   *
   * @default 0.8
   */
  public diffuse: number;

  /**
   * The number of points which will be used for shadow projection.
   * It defines the quality of the rendering.
   *
   * @default 1
   */
  public samples: number;

  /**
   * Whether the light is hidden or not.
   *
   * @default false
   */
  public hidden: boolean;

  protected id?: number;

  #vismaskHash?: string;

  #vismaskCache?: CanvasAndContext;

  /**
   * @param options - Options to be applied to the light object.
   */
  public constructor(options: LightOptions = {}) {
    const { position, distance, diffuse, samples, hidden } = options;

    this.position = position ?? new Vec2();
    this.distance = distance ?? 100;
    this.diffuse = diffuse ?? 0.8;
    this.samples = samples ?? 1;
    this.hidden = hidden ?? false;
  }

  /**
   * Render the light onto the given context.
   *
   * @param _context - The canvas context onto which the light will be rendered.
   */
  public render(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _context: CanvasRenderingContext2D
  ): void {
    //
  }

  /**
   * Render a mask representing the visibility. (Used by {@linkcode DarkMask})
   *
   * @param context - The canvas context onto which the mask will be rendered.
   */
  public mask(context: CanvasRenderingContext2D): void {
    const cache = this.getVisibleMaskCache()!;

    const { x, y } = this.position;

    context.drawImage(cache.canvas, Math.round(x - cache.w / 2), Math.round(y - cache.h / 2));
  }

  /**
   * Calculate the boundaries of the light using the light's distance.
   *
   * @returns An anonymous object with the properties `topLeft` and `bottomRight`.
   * The property values are {@linkcode Vec2} objects representing the corners of the boundary.
   */
  public bounds(): Bounds {
    const { position, distance } = this;

    const { x, y } = position;

    return {
      topLeft: new Vec2(x - distance, y - distance),
      bottomRight: new Vec2(x + distance, y + distance)
    };
  }

  /**
   * Return the center of the light.
   * i.e. The position where the light intensity is the highest.
   *
   * @returns A new vector that represents the center of the light.
   */
  public center(): Vec2 {
    const { distance } = this;

    return new Vec2(distance, distance);
  }

  /**
   * Invoke a function for every sample generated by the light.
   * Implement it by spreading samples and calling {@linkcode callback} at each time.
   *
   * @param callback - Function to be called for every sample.
   * The function will be passed a vector representing the position of the sample.
   */
  public forEachSample(callback: (position: Vec2) => void): void {
    callback(this.position);
  }

  /**
   * Creates a canvas context with the visible mask rendered onto it.
   *
   * @returns A canvas context with the visible mask rendered onto it.
   */
  protected getVisibleMaskCache(): CanvasAndContext | undefined {
    // By default use a radial gradient based on the distance
    const d = Math.floor(this.distance * 1.4);
    const hash = `${d}`;

    // Prevent the distance from being too small
    if (d < 1) return;

    if (this.#vismaskHash !== hash) {
      this.#vismaskHash = hash;
      this.#vismaskCache = createCanvasAnd2dContext(`vm${this.id!}`, 2 * d, 2 * d);

      const { ctx, w, h } = this.#vismaskCache;

      const gradient = ctx.createRadialGradient(d, d, 0, d, d, d);

      gradient.addColorStop(0, "rgba(0,0,0,1)");
      gradient.addColorStop(1, "rgba(0,0,0,0)");

      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, w, h);
    }

    return this.#vismaskCache;
  }

  /**
   * Return a string hash key representing the light.
   *
   * @returns The hash key.
   */
  protected getHashCache(): string {
    return [this.distance, this.diffuse].toString();
  }
}
